package org.sag.common.tools;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import org.sag.acminer.IACMinerDataAccessor;
import soot.ArrayType;
import soot.Body;
import soot.ClassMember;
import soot.FastHierarchy;
import soot.Local;
import soot.NullType;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootFieldRef;
import soot.SootMethod;
import soot.SootMethodRef;
import soot.Unit;
import soot.jimple.DynamicInvokeExpr;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.SpecialInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.Stmt;
import soot.jimple.toolkits.pointer.LocalMustNotAliasAnalysis;
import soot.options.Options;
import soot.toolkits.graph.ExceptionalUnitGraph;

public class HierarchyHelpers {

	/**
	 * Returns all the sub-classes of a given class including the given class. These sub-classes are
	 * directly and indirectly related to the given class. An Interface will return an empty set.
	 */
	public static Set<SootClass> getAllSubClasses(SootClass parent) {
		if (parent.isInterface())
			return Collections.<SootClass> emptySet();

		Set<SootClass> allSubClasses = new HashSet<SootClass>();
		Collection<SootClass> parentSubClasses = Scene.v().getOrMakeFastHierarchy()
				.getSubclassesOf(parent);

		allSubClasses.add(parent);
		for (SootClass subClass : parentSubClasses) {
			allSubClasses.addAll(getAllSubClasses(subClass));
		}
		return allSubClasses;
	}
	
	/* Note FastHierarchy's getAllSubinterfaces(SootClass) includes all direct and 
	 * indirect implementers of the given parent interface. This does not return any
	 * sub classes. This method does return a set that includes the parent interface.
	 */

	/**
	 * This method is an extension of the FastHierarchy's method getAllImplementersOfInterface(SootClass).
	 * Instead of just returning the direct implementers of the parent interface, all the direct 
	 * interfaces of the parent, and all the indirect interfaces of the parent (i.e. all interfaces returned by 
	 * FastHierarchy's method getAllSubinterfaces(SootClass) called on parent), this method will return every
	 * sub class of this parent interface. That is every direct or indirect sub class of the parent interface.
	 * 
	 * This means that just like FastHierarchy's getAllImplementersOfInterface(SootClass) method, no interfaces
	 * are returned (including the parent because that is an interface). Only actual classes are returned.
	 * 
	 * @see FastHierarchy#getAllImplementersOfInterface(SootClass)
	 * @see FastHierarchy#getAllSubinterfaces(SootClass)
	 */
	public static Set<SootClass> getAllSubClassesOfInterface(SootClass parent) {
		if (!parent.isInterface())
			return Collections.<SootClass> emptySet();

		Set<SootClass> implementersSet = Scene.v().getOrMakeFastHierarchy()
				.getAllImplementersOfInterface(parent);
		Set<SootClass> allSubClasses = new HashSet<SootClass>();

		for (SootClass subClass : implementersSet) {
			allSubClasses.addAll(getAllSubClasses(subClass));
		}
		return allSubClasses;
	}

	/*
	 * Produces a set of all the methods that implement all the methods defined in a given interface
	 * or class excluding constructions and static initializers. That is for an interface, it will
	 * produce a set of all methods that implement (have bodies or are native) all methods defined
	 * in the interface. For a class, it will produce a set of all methods that override the methods
	 * in the class including the implemented methods of the given class.
	 */
	public static Set<SootMethod> getAllImplementingMethods(SootClass org) {
		Set<SootClass> classes;
		HashSet<String> subSigs = new HashSet<String>();
		HashSet<SootMethod> allImpMeth = new HashSet<SootMethod>();

		if (org.isInterface()) {
			classes = getAllSubClassesOfInterface(org);
		} else {
			classes = getAllSubClasses(org);
		}

		for (SootMethod m : org.getMethods()) {
			subSigs.add(m.getSubSignature());
		}

		for (SootClass c : classes) {
			for (SootMethod m : c.getMethods()) {
				if (!m.isAbstract() && !m.getName().equals("<init>")
						&& !m.getName().equals("<clinit>") && subSigs.contains(m.getSubSignature())) {
					allImpMeth.add(m);
				}
			}
		}
		return allImpMeth;
	}
	
	/** Given a method sub-signature and a class, this method returns all the method signatures that will refer to the same method as the 
	 * signature generated by the sub-signature + class combination. 
	 * 
	 * @param start
	 * @param subSignature
	 * @return
	 */
	public static Set<String> getAllPossibleInvokeSignaturesForMethod(SootMethod m, IACMinerDataAccessor dataAccessor) {
		return getAllPossibleInvokeSignaturesForMethod(m.getDeclaringClass(), m.getSubSignature(), dataAccessor);
	}
	
	/** Given a method sub-signature and a class, this method returns all the method signatures that will refer to the same method as the 
	 * signature generated by the sub-signature + class combination. 
	 * 
	 * @param start
	 * @param subSignature
	 * @return
	 */
	public static Set<String> getAllPossibleInvokeSignaturesForMethod(SootClass start, String subSignature, IACMinerDataAccessor dataAccessor) {
		Set<String> ret = new HashSet<>();
		if(start.isInterface()) {
			/* has no super class only parent interfaces and there can be mutiple of these
			 * need to find the first parent interface with the method in each chain from the start to the object class on all paths
			 * Since this is an interface we have two options:
			 *   1. It is declared in the current interface or its super interfaces. In either case, it is always public, abstract, non-final,
			 *   and non-static. However, the method is not defined anywhere so the actual invoke could be any method matching the sub-signature.
			 *   Moreover, since it is public we do not have to worry about private, protected, or no-modifiers.
			 *   2. It is not declared in any of the interfaces so the method is not accessible from the start interface.
			 */
			ret.addAll(getAllSuperInvokeSignaturesOfInterface(start,subSignature));
			if(ret.isEmpty()) {
				return Collections.emptySet();
			} else {
				//Note we need both loops because we want to include the signatures generated from the sub-interfaces as well as
				//the subclasses
				for(SootClass sc : Scene.v().getOrMakeFastHierarchy().getAllImplementersOfInterface(start)) {
					ret.add(SootMethod.getSignature(sc, subSignature));
				}
				for(SootClass sc : getAllSubClassesOfInterface(start)) {
					ret.add(SootMethod.getSignature(sc, subSignature));
				}
			}
		} else {
			/* This is is an actual class so we need to know the actual method we are referring to. Otherwise, it could be anything.
			 * So we have several situations:
			 *   1. There is no defined method we can resolve to in the start or super classes and there is no declared method of the given
			 *   signature either. In this case we return nothing because the method is not accessible.
			 *   2. There is no defined method we can resolve to in the start or super classes but there is a declared method in the start
			 *   or super classes. In this case, we include all of the sub classes since this is basically the same situation as the interface
			 *   method. Though we do need to consider the visibility.
			 *   3. There is a defined method. If it is private we return just the single method. If it is static we include only the signatures
			 *   between the methods defining class and start and then all subclasses. Otherwise, we include all subclasses and super classes.
			 *   This is all has to take into account visibility.
			 */
			//Try to find the method being referenced by the given invoke signature
			SootMethod target = null;
			SootClass curLoop = start;
			while(curLoop != null) {
				SootMethod m = curLoop.getMethodUnsafe(subSignature);
				if(m != null && !m.isAbstract() && !m.isPhantom() && isVisible(start,m)) {
					target = m;
					break;
				}
				if(curLoop.hasSuperclass())
					curLoop = curLoop.getSuperclass();
				else
					curLoop = null;
			}
			if(target != null) {
				if(target.isPrivate()) {
					return Collections.singleton(target.getSignature());//Private can always only have one invoke signature
				} else if(target.isStatic()) {
					//Static methods are only visible in the class they are defined and the sub-classes until overridden
					//We know this static method is not overridden between its definition class and start so we want all of those signatures
					SootClass loop = start;
					while(loop != null) {
						ret.add(SootMethod.getSignature(loop, subSignature));
						if(target.getDeclaringClass().equals(loop))
							break;
						if(loop.hasSuperclass())
							loop = loop.getSuperclass();
						else
							loop = null;
					}
				} else {
					//The method is defined as given but could be declared else where in the hierarchy and thus accessible 
					Deque<SootClass> classH = new ArrayDeque<>();
					classH.add(start);
					while(classH.peekFirst().hasSuperclass()) {
						classH.push(classH.peekFirst().getSuperclass());
					}
					boolean startGathering = false;
					for(SootClass sc : classH) {
						Set<String> interfaceSuperInvokes = new HashSet<>();
						for(SootClass iface : sc.getInterfaces()) {
							interfaceSuperInvokes.addAll(getAllSuperInvokeSignaturesOfInterface(iface, subSignature));
						}
						ret.addAll(interfaceSuperInvokes);
						if(startGathering) {
							ret.add(SootMethod.getSignature(sc, subSignature));
						} else if((sc.declaresMethod(subSignature) && isVisible(start,sc.getMethod(subSignature))) 
								|| !interfaceSuperInvokes.isEmpty()) {
							//If it is declared then it is abstract but we need to make sure it is visible
							//If it is declared in an interface then it is always visible because public
							startGathering = true;
							ret.add(SootMethod.getSignature(sc, subSignature));
						}
					}
					//if this is an entry point, then it can be called through binder so we need to include all of the possible
					//binder proxy invoke statements as well. Stub invoke statements will be taken care of by the class hierarchy.
					if(dataAccessor.getEntryPointsAsSootMethods().contains(target)) {
						Map<SootMethod,Set<SootMethod>> ifaceToEp = dataAccessor.getBinderInterfaceMethodsToEntryPoints();
						for(SootMethod i : ifaceToEp.keySet()) {
							if(ifaceToEp.get(i).contains(target)) {
								ret.add(i.toString());
								for(SootMethod m : dataAccessor.getBinderProxyMethodsForInterfaceMethod(i)) {
									ret.add(m.toString());
								}
								
							}
						}
					}
				}
				Queue<SootClass> queue = new ArrayDeque<>();
				queue.addAll(Scene.v().getOrMakeFastHierarchy().getSubclassesOf(start));//skip start because start may declare the method
				while(!queue.isEmpty()) {
					SootClass cur = queue.poll();
					//Include all subclasses as signatures if target is final and remains visible since the method cannot be overridden
					//So long as the method remains visible to a class and it does not override the method keep going
					if(target.isFinal() && isVisible(cur,target) && !cur.declaresMethod(subSignature)) {
						ret.add(SootMethod.getSignature(cur, subSignature));
						queue.addAll(Scene.v().getOrMakeFastHierarchy().getSubclassesOf(cur));
					}
				}
			} else {
				//We could not find a concrete method for the method being referenced by the given invoke signature
				//It could be declared but not defined (i.e. it could be abstract and therefore not static)
				Deque<SootClass> classH = new ArrayDeque<>();
				classH.add(start);
				while(classH.peekFirst().hasSuperclass()) {
					classH.push(classH.peekFirst().getSuperclass());
				}
				boolean startGathering = false;
				SootMethod lowestTargetDecl = null;
				for(SootClass sc : classH) {
					Set<String> interfaceSuperInvokes = new HashSet<>();
					for(SootClass iface : sc.getInterfaces()) {
						interfaceSuperInvokes.addAll(getAllSuperInvokeSignaturesOfInterface(iface, subSignature));
					}
					ret.addAll(interfaceSuperInvokes);
					if(startGathering) {
						ret.add(SootMethod.getSignature(sc, subSignature));
					} else if((sc.declaresMethod(subSignature) && isVisible(start,sc.getMethod(subSignature))) 
							|| !interfaceSuperInvokes.isEmpty()) {
						//If it is declared then it is abstract but we need to make sure it is visible
						//If it is declared in an interface then it is always visible because public
						startGathering = true;
						ret.add(SootMethod.getSignature(sc, subSignature));
					}
					if(sc.declaresMethod(subSignature))
						lowestTargetDecl = sc.getMethod(subSignature);
					if(!interfaceSuperInvokes.isEmpty())
						//The method must be public since it is declared in an interface use null + ret not being empty as indication of this
						lowestTargetDecl = null;
				}
				if(ret.isEmpty()) {
					//The method is not declared in the start classes parent/interface hierarchy and it is not declared in the start class
					//Therefore the method is not accessible from this start class so we return nothing
					return Collections.emptySet();
				} else {
					//The method has not been defined yet only declared so the signature generated by sub-signature + start class
					//could refer to any method of sub-signature defined in a subclass of the start class
					Queue<SootClass> queue = new ArrayDeque<>();
					queue.addAll(Scene.v().getOrMakeFastHierarchy().getSubclassesOf(start));//skip start because start may declare the method
					while(!queue.isEmpty()) {
						SootClass cur = queue.poll();
						//Any method of sub-sig is possible in the subclasses so long as the declared method remains visible in these classes
						//We don't worry about overriding here because we have no target method
						//The visibility check is really for situations where an abstract method is declared package-private and a sub class
						//exists outside of the abstract classes package
						if(lowestTargetDecl == null || isVisible(cur,lowestTargetDecl)) {
							ret.add(SootMethod.getSignature(cur, subSignature));
							queue.addAll(Scene.v().getOrMakeFastHierarchy().getSubclassesOf(cur));
						}
					}
				}
			}
		}
		if(ret.isEmpty())
			return Collections.emptySet();
		return ret;
	}
	
	public static Set<String> getAllSuperInvokeSignaturesOfInterface(SootClass start, String subSignature) {
		if(start.isInterface()) {
			List<PathContainer> finished = new ArrayList<>();
			Queue<PathContainer> queue = new ArrayDeque<>();
			queue.add(new PathContainer(start, start.declaresMethod(subSignature)));
			while(!queue.isEmpty()) {
				PathContainer p = queue.poll();
				SootClass front = p.path.peekFirst();
				if(front.getInterfaceCount() == 0) {
					if(p.firstInstance != null)
						finished.add(p);
				} else if(front.getInterfaceCount() == 1) {
					SootClass newFront = front.getInterfaces().getFirst();
					p.addFront(newFront, newFront.declaresMethod(subSignature));
					if(p.hasCycle()) {
						if(p.firstInstance != null)
							finished.add(p);
					} else {
						queue.add(p);
					}
				} else {
					for(SootClass newFront : front.getInterfaces()) {
						PathContainer newP = p.cloneAndAdd(newFront,newFront.declaresMethod(subSignature));
						if(newP.hasCycle()) {
							if(newP.firstInstance != null)
								finished.add(newP);
						} else {
							queue.add(newP);
						}
					}
				}
			}
			if(finished.isEmpty())
				return Collections.emptySet();
			Set<String> ret = new HashSet<>();
			for(PathContainer p : finished) {
				boolean startGathering = false;
				for(SootClass sc : p.getPath()) {
					if(startGathering) {
						ret.add(SootMethod.getSignature(sc, subSignature));
					} else if(sc.equals(p.getFirst())) {
						startGathering = true;
						ret.add(SootMethod.getSignature(sc, subSignature));
					}
				}
			}
			return ret;
		}
		return Collections.emptySet();
	}
	
	private static final class PathContainer {
		private SootClass firstInstance;
		private Deque<SootClass> path;
		private Set<SootClass> seen;
		private boolean hasCycle;
		private PathContainer(PathContainer curPath) {
			path = new ArrayDeque<>(curPath.path);
			seen = new HashSet<>(curPath.seen);
			firstInstance = curPath.firstInstance;
			hasCycle = curPath.hasCycle;
		}
		public PathContainer(SootClass start, boolean declaresMethod) {
			path = new ArrayDeque<>();
			path.push(start);
			seen = new HashSet<>();
			seen.add(start);
			if(declaresMethod) 
				firstInstance = start;
			else
				firstInstance = null;
			hasCycle = false;
		}
		public PathContainer cloneAndAdd(SootClass curClass, boolean declaresMethod) {
			PathContainer newPath = new PathContainer(this);
			newPath.path.push(curClass);
			if(declaresMethod)
				newPath.firstInstance = curClass;
			if(!newPath.seen.add(curClass))
				newPath.hasCycle = true;
			return newPath;
		}
		public void addFront(SootClass newFront, boolean declaresMethod) {
			path.push(newFront);
			if(declaresMethod)
				firstInstance = newFront;
			if(!seen.add(newFront))
				hasCycle = true;
		}
		public boolean hasCycle() { return hasCycle; }
		public SootClass getFirst() { return firstInstance; }
		public Deque<SootClass> getPath() { return path; }
	}
	
	public static Set<String> getAllPossibleInvokeSignatures(SootMethod m) {
		return getAllPossibleInvokeSignatures(m.getDeclaringClass(), m.getSubSignature());
	}
	
	public static Set<String> getAllPossibleInvokeSignatures(SootClass parentClass, String subSignature) {
		Set<SootClass> classHierarchy = new HashSet<>();
		if(parentClass.isInterface()) {
			//does not include the sub interfaces just the subclasses
			classHierarchy.addAll(HierarchyHelpers.getAllSubClassesOfInterface(parentClass));
			//include all sub interfaces
			classHierarchy.addAll(Scene.v().getOrMakeFastHierarchy().getAllSubinterfaces(parentClass));
			//add the parent just in case
			classHierarchy.add(parentClass);
		} else {
			classHierarchy.addAll(HierarchyHelpers.getAllSubClasses(parentClass));
		}
		Set<String> ret = new HashSet<>();
		for(SootClass sc : classHierarchy) {
			ret.add(SootMethod.getSignature(sc, subSignature));
		}
		return ret;
	}
			
	public static Set<SootMethod> getAllPossibleInvokeTargets(SootMethod caller, Unit u){
		if(!(u instanceof Stmt) || !((Stmt)u).containsInvokeExpr())
			return Collections.emptySet();
		
		Body body = caller.retrieveActiveBody();
		return getAllPossibleInvokeTargets(new LocalMustNotAliasAnalysis(new ExceptionalUnitGraph(body), body),u);
	}
	
	public static Set<SootMethod> getAllPossibleInvokeTargets(LocalMustNotAliasAnalysis lmnaa, Unit u){
		if(!(u instanceof Stmt) || !((Stmt)u).containsInvokeExpr())
			return Collections.emptySet();
		
		Stmt stmt = (Stmt)u;
		InvokeExpr ie = stmt.getInvokeExpr();
		if(ie instanceof StaticInvokeExpr){
			return Collections.singleton(ie.getMethod());
		}else if(ie instanceof DynamicInvokeExpr){
			/* Currently this returns a method in the phantom class 'soot.dummy.InvokeDynamic' which is used to house the method descriptions
			 * of invokedynamic instructions as these method descriptions do not provide a source class. The source class is determined at
			 * runtime by the lookup routine. As this class is phantom and special, there will be only a single method resolution for
			 * this method reference. This will need to be updated if Soot ever provides a way to resolve invokedynamic instructions.
			 */
			return Collections.singleton(ie.getMethod());
		}else{//InstanceInvokeExpr
			InstanceInvokeExpr iie = (InstanceInvokeExpr)ie;
			if(iie instanceof SpecialInvokeExpr){
				SootMethod singleTargetMethod = resolveSpecialDispatch(iie.getMethodRef());
				if(singleTargetMethod == null)
					return Collections.emptySet();
				return Collections.singleton(singleTargetMethod);
				//return Collections.singleton(ie.getMethod());
			}else{
				Local base = (Local) iie.getBase();
				RefType concreteType = lmnaa.concreteType(base, stmt);
				if(concreteType!=null) {
					//the base variable definitely points to a single concrete type 
					SootMethod singleTargetMethod = resolveConcreteDispatch(concreteType.getSootClass(), iie.getMethodRef());
					if(singleTargetMethod == null)
						return Collections.emptySet();
					return Collections.singleton(singleTargetMethod);
				} else {
					SootClass baseTypeClass;
					if(base.getType() instanceof RefType) {
						RefType refType = (RefType) base.getType();
						baseTypeClass = refType.getSootClass();
					} else if(base.getType() instanceof ArrayType) {
						baseTypeClass = Scene.v().getSootClass("java.lang.Object");
					} else if(base.getType() instanceof NullType) {
						//if the base is definitely null then there is no call target
						return Collections.emptySet();
					} else {
						throw new InternalError("Unexpected base type:"+base.getType());
					}
					return resolveAbstractDispatch(baseTypeClass, iie.getMethodRef());
				}
			}
		}
	}
	
	/** Returns true if the ClassMember is visible from code in the class 'from' where
	 * 'from' is assumed to be a sub-class or equal to the declaring class of the 
	 * ClassMember. Because of this assumption, we do not need to check the class 
	 * access modifiers since these control if the class is visible and clearly it
	 * is in some way since it 'from' is a sub-class of the declaring class of the
	 * ClassMember. The real question is if the fields and methods are visible.
	 */
	private static boolean isVisible(SootClass from, ClassMember m) {
		from.checkLevel(SootClass.HIERARCHY);
		m.getDeclaringClass().checkLevel(SootClass.HIERARCHY);
		if(m.isPublic()) return true;
		if(m.isPrivate()) return from.equals(m.getDeclaringClass());
		if(m.isProtected()) return Scene.v().getOrMakeFastHierarchy().isSubclass(from, m.getDeclaringClass());
		return from.getJavaPackageName().equals(m.getDeclaringClass().getJavaPackageName());
	}
	
	/** See {@link #resolveSpecialDispatch(SootClass, SootMethodRef)} */
	public static SootMethod resolveSpecialDispatch(SootMethod m){
		return resolveSpecialDispatch(m.makeRef());
	}
	
	/** This method attempts to resolve a method reference that originates from an invokespecial statement to a single non abstract method
	 * (i.e. native, phantom, or normal). An invokespecial statement can be invoking an "init" method of the declaring class or the
	 * method reference, a private method of the declaring class of the method reference, or a method in a super class of the declaring
	 * class of the method reference. If it is invoking an "init" method we just resolve it and otherwise we use 
	 * {@link #resolveConcreteDispatch(SootClass, SootMethodRef)} to resolve the method.
	 */
	public static SootMethod resolveSpecialDispatch(SootMethodRef methodRef){
		if(methodRef.name().equals("<init>"))
			return methodRef.resolve();
		else
			return resolveConcreteDispatch(methodRef);
	}
	
	/** See {@link #resolveConcreteDispatch(SootClass, SootMethodRef)} */
	public static SootMethod resolveConcreteDispatch(SootMethod m){
		return resolveConcreteDispatch(m.makeRef());
	}
	
	/** See {@link #resolveConcreteDispatch(SootClass, SootMethodRef)} */
	public static SootMethod resolveConcreteDispatch(SootClass startClass, SootMethod m){
		return resolveConcreteDispatch(startClass,m.makeRef());
	}
	
	/** See {@link #resolveConcreteDispatch(SootClass, SootMethodRef)} */
	public static SootMethod resolveConcreteDispatch(SootMethodRef methodRef){
		return resolveConcreteDispatch(methodRef.declaringClass(),methodRef);
	}
	
	/** This method attempts to resolve a method reference to a single non abstract method (i.e. native, phantom, or normal)
	 * based on the class hierarchy. That is given the starting class (which may or may not be the declaring class of the method
	 * reference) it will search for all methods matching the SubSignature of the method reference in the starting class's super
	 * class list who are not abstract and who are visible to the starting class. This method will only work on classes and 
	 * abstract class (i.e. not interfaces) and assumes that if it is an abstract class the method has a resolution somewhere
	 * in the subclass list. If a resolution for the method reference is not found then null is returned (also returned is an
	 * interface class is provided).
	 */
	public static SootMethod resolveConcreteDispatch(SootClass startClass, SootMethodRef methodRef){
		startClass.checkLevel(SootClass.HIERARCHY);
		if(startClass.isInterface())
			return null;
		
		String methodSubSig = SootMethod.getSubSignature(methodRef.name(), methodRef.parameterTypes(), methodRef.returnType());
		SootClass concreteType = startClass;
		while(true) {
			SootMethod method = concreteType.getMethodUnsafe(methodSubSig);
			if(method != null && isVisible(startClass, method)){ 
				if(!method.isAbstract())
					return method;
				else
					return null;
			}
			if(!concreteType.hasSuperclass()) 
				break;
			concreteType = concreteType.getSuperclass();
		} 
		return null;
	}
	
	/** See {@link #resolveAbstractDispatch(SootClass, SootMethodRef)} */
	public static Set<SootMethod> resolveAbstractDispatch(SootMethod m){
		return resolveAbstractDispatch(m.makeRef());
	}
	
	/** See {@link #resolveAbstractDispatch(SootClass, SootMethodRef)} */
	public static Set<SootMethod> resolveAbstractDispacth(SootClass startClass, SootMethod m){
		return resolveAbstractDispatch(startClass,m.makeRef());
	}
	
	/** See {@link #resolveAbstractDispatch(SootClass, SootMethodRef)} */
	public static Set<SootMethod> resolveAbstractDispatch(SootMethodRef methodRef){
		return resolveAbstractDispatch(methodRef.declaringClass(),methodRef);
	}
	
	/** This method attempts to resolve a method reference to all possible non abstract methods (i.e. native, phantom, or normal)
	 * based on the class hierarchy. That is given the starting class (which may or may not be the declaring class of the method
	 * reference) it will search for all methods matching the SubSignature of the method reference in the starting class's super
	 * class list and in its sub-class list who are not abstract and who are visible to the starting class. This method works 
	 * for interfaces, abstract classes, and normal classes.
	 */
	public static Set<SootMethod> resolveAbstractDispatch(SootClass startClass, SootMethodRef methodRef){
		String methodSubSig = SootMethod.getSubSignature(methodRef.name(), methodRef.parameterTypes(), methodRef.returnType());
		HashSet<SootClass> visited = new HashSet<SootClass>();
		HashSet<SootMethod> ret = new HashSet<SootMethod>();
		Deque<SootClass> worklist = new ArrayDeque<>();
		FastHierarchy fh = Scene.v().getOrMakeFastHierarchy();
		boolean foundPrivate = false;
		
		worklist.add(startClass);
		while(!worklist.isEmpty()){
			SootClass currentClass = worklist.poll();
			SootClass orginalClass = currentClass;
			//SootClass startingClass = currentClass;
			
			//If the current class is an interface then we know all methods are either abstract or static 
			//We ignore static methods as this method is meant to resolve abstract ones
			//So we can just generate all the implementers of the interface (i.e. sub-classes that stop at the first non-interface instance)
			if(currentClass.isInterface()){
				worklist.addAll(fh.getAllImplementersOfInterface(currentClass));
				continue;
			}
			//This is not an interface so we need to consider all of its sub classes
			worklist.addAll(fh.getSubclassesOf(currentClass));
			
			/* Attempt to resolve the method ref to the first visible, concrete, method starting at the current class and going down the 
			 * SuperClass chain until the class "java.lang.Object" is encountered.
			 * The class could be:
			 *	 1. Abstract and contain a concrete version of the method
			 *	 2. Abstract and have the method defined in a SuperClass
			 *	 3. Abstract and have the method defined in one or more sub classes (in which case we will find it when those are looked at later)
			 *	 4. Concrete and contain a concrete version of the method
			 *	 5. Concrete and has the method defined in a SuperClass
			 */
			while(true){
				//If we have visited this class before no need to look at it or anything below it again
				if(visited.contains(currentClass))
					break;
				visited.add(currentClass);
				
				//Search for a method of the SubSignature in the current class
				SootMethod method = currentClass.getMethodUnsafe(methodSubSig);
				/* If found check to make sure the class we started at can actually see the method as it could be private or package
				 * private and thus potentially hidden from the starting class and we could actually be looking for another method
				 * with the same SubSignature defined in an interface that is visible to the starting class. Also check to make sure
				 * it is not abstract as we are trying to resolve to actual methods and not place holders.
				 */
				if(method != null && isVisible(orginalClass,method)){
					if(!method.isAbstract()){
						if(method.isPrivate() && method.getDeclaringClass().equals(startClass)){
							ret.clear();
							foundPrivate = true;
						}
						ret.add(method);
					}
					break;
				}
				//If the current class had no super class then it is 'java.lang.Object' so we stop searching
				//It is possible to reach this point if the starting class is abstract in which case the method is in its subclasses
				if(!currentClass.hasSuperclass())
					break;
				currentClass = currentClass.getSuperclass();
			}
			if(foundPrivate)
				break;
		}
		return ret;
	}
	
	/* The same as the checkStatic method in AbstractSootFieldRef except it does not throw an exception
	 * if it fails, it just returns null.
	 */
	public static SootField checkStaticField(SootField ret, SootFieldRef ref) {
		if((Options.v().wrong_staticness() == Options.wrong_staticness_fail || Options.v().wrong_staticness() == Options.wrong_staticness_fixstrict)
					&& ret.isStatic() != ret.isStatic() && !ret.isPhantom()) {
			return null;
		}
		return ret;
	}
	
	/* The same as the resolve method in AbstractSootFieldRef except it does not throw an exception
	 * and will not create a field if the field does not exist and phantom classes are enabled. If
	 * the field cannot be resolved then null is returned always.
	 */
	public static SootField resolveField(SootFieldRef ref) {
		SootClass cl = ref.declaringClass();
		while (true) {
			// Check whether we have the field in the current class
			SootField clField = cl.getFieldUnsafe(ref.name(), ref.type());
			if (clField != null) {
				return checkStaticField(clField, ref);
			} else if (Scene.v().allowsPhantomRefs() && cl.isPhantom()) {
				return null;
			} else {
				// Since this class is not phantom, we look at its interfaces
				ArrayDeque<SootClass> queue = new ArrayDeque<SootClass>();
				queue.addAll(cl.getInterfaces());
				while (true) {
					SootClass iface = queue.poll();
					if (iface == null) {
						break;
					}

					SootField ifaceField = iface.getFieldUnsafe(ref.name(), ref.type());
					if (ifaceField != null) {
						return checkStaticField(ifaceField, ref);
					}
					queue.addAll(iface.getInterfaces());
				}

				// If we have not found a suitable field in the current class, try the superclass
				if (cl.hasSuperclass()) {
					cl = cl.getSuperclass();
				} else {
					break;
				}
			}
		}
		return null;
	}

}
